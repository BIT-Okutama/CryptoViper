{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"buffer\");\n\nvar _permute = _interopRequireDefault(require(\"./permute\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar allowedCapacityValues = [224, 256, 384, 512];\n\nvar writeState = function writeState(I, O) {\n  for (var i = 0; i < I.length; i += 8) {\n    var o = i / 4;\n    O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];\n    O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];\n  }\n};\n\nvar readHash = function readHash(I, n) {\n  var O = _buffer.Buffer.allocUnsafe(n);\n\n  for (var o = 0; o < n; o += 8) {\n    var i = o / 4;\n    O[o] = I[i + 1];\n    O[o + 1] = I[i + 1] >>> 8;\n    O[o + 2] = I[i + 1] >>> 16;\n    O[o + 3] = I[i + 1] >>> 24;\n    O[o + 4] = I[i];\n    O[o + 5] = I[i] >>> 8;\n    O[o + 6] = I[i] >>> 16;\n    O[o + 7] = I[i] >>> 24;\n  }\n\n  return O;\n};\n\nvar Sponge = function Sponge(_ref) {\n  var _this = this;\n\n  var capacity = _ref.capacity,\n      padding = _ref.padding;\n\n  if (!allowedCapacityValues.includes(capacity)) {\n    throw new Error(\"Unsupported hash length\");\n  }\n\n  var keccak = (0, _permute.default)();\n  var stateSize = 200;\n  var hashSize = capacity / 8;\n  var queueSize = stateSize - hashSize * 2;\n  var queueOffset = 0;\n  var state = new Uint32Array(stateSize / 4);\n\n  var queue = _buffer.Buffer.allocUnsafe(queueSize);\n\n  this.absorb = function (buffer) {\n    for (var i = 0; i < buffer.length; i++) {\n      queue[queueOffset] = buffer[i];\n      queueOffset += 1;\n\n      if (queueOffset >= queueSize) {\n        writeState(queue, state);\n        keccak(state);\n        queueOffset = 0;\n      }\n    }\n\n    return _this;\n  };\n\n  this.squeeze = function () {\n    var output = {\n      queue: _buffer.Buffer.allocUnsafe(queueSize),\n      state: new Uint32Array(stateSize / 4)\n    };\n    queue.copy(output.queue);\n\n    for (var i = 0; i < state.length; i++) {\n      output.state[i] = state[i];\n    }\n\n    output.queue.fill(0, queueOffset);\n    output.queue[queueOffset] |= padding;\n    output.queue[queueSize - 1] |= 128;\n    writeState(output.queue, output.state);\n    keccak(output.state);\n    return readHash(output.state, hashSize);\n  };\n\n  this.reset = function () {\n    queue.fill(0);\n    state.fill(0);\n    queueOffset = 0;\n    return _this;\n  };\n\n  return this;\n};\n\nvar _default = Sponge;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}