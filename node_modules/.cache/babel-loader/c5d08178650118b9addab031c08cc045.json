{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\empty\\\\Documents\\\\IT\\\\CryptoViper\\\\cryptoviper\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\empty\\\\Documents\\\\IT\\\\CryptoViper\\\\cryptoviper\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\empty\\\\Documents\\\\IT\\\\CryptoViper\\\\cryptoviper\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\empty\\\\Documents\\\\IT\\\\CryptoViper\\\\cryptoviper\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\empty\\\\Documents\\\\IT\\\\CryptoViper\\\\cryptoviper\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"C:\\\\Users\\\\empty\\\\Documents\\\\IT\\\\CryptoViper\\\\cryptoviper\\\\src\\\\BodyComponent\\\\LessonComponent\\\\LessonBody.js\";\nimport React, { Component } from 'react';\n\nvar LessonBody =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(LessonBody, _Component);\n\n  function LessonBody() {\n    _classCallCheck(this, LessonBody);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LessonBody).apply(this, arguments));\n  }\n\n  _createClass(LessonBody, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", {\n        class: \"lessonbody\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 6\n        },\n        __self: this\n      }, React.createElement(\"p\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 7\n        },\n        __self: this\n      }, \"Chapter 2: Contracts Starting with the absolute basics: Solidity's code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications \\u2014 all variables and functions belong to a contract, and this will be the starting point of all your projects. An empty contract named HelloWorld would look like this: contract HelloWorld \", \"Version Pragma All solidity source code should start with a \\\"version pragma\\\" \\u2014 a declaration of the version of the Solidity compiler this code should use. This is to prevent issues with future compiler versions potentially introducing changes that would break your code. It looks like this: pragma solidity ^0.4.25; (for the latest solidity version at the time of this writing, 0.4.25). Putting it together, here is a bare-bones starting contract \\u2014 the first thing you'll write every time you start a new project: pragma solidity ^0.4.25; contract HelloWorld \", \"Put it to the test To start creating our Zombie army, let's create a base contract called ZombieFactory. In the box to the right, make it so our contract uses solidity version 0.4.25. Create an empty contract called ZombieFactory. When you're finished, click \\\"check answer\\\" below. If you get stuck, you can click \\\"hint\\\". Chapter 2: Contracts Starting with the absolute basics: Solidity's code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications \\u2014 all variables and functions belong to a contract, and this will be the starting point of all your projects. An empty contract named HelloWorld would look like this: contract HelloWorld \", \"Version Pragma All solidity source code should start with a \\\"version pragma\\\" \\u2014 a declaration of the version of the Solidity compiler this code should use. This is to prevent issues with future compiler versions potentially introducing changes that would break your code. It looks like this: pragma solidity ^0.4.25; (for the latest solidity version at the time of this writing, 0.4.25). Putting it together, here is a bare-bones starting contract \\u2014 the first thing you'll write every time you start a new project: pragma solidity ^0.4.25; contract HelloWorld \", \"Put it to the test To start creating our Zombie army, let's create a base contract called ZombieFactory. In the box to the right, make it so our contract uses solidity version 0.4.25. Create an empty contract called ZombieFactory. When you're finished, click \\\"check answer\\\" below. If you get stuck, you can click \\\"hint\\\". Chapter 2: Contracts Starting with the absolute basics: Solidity's code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications \\u2014 all variables and functions belong to a contract, and this will be the starting point of all your projects. An empty contract named HelloWorld would look like this: contract HelloWorld \", \"Version Pragma All solidity source code should start with a \\\"version pragma\\\" \\u2014 a declaration of the version of the Solidity compiler this code should use. This is to prevent issues with future compiler versions potentially introducing changes that would break your code. It looks like this: pragma solidity ^0.4.25; (for the latest solidity version at the time of this writing, 0.4.25). Putting it together, here is a bare-bones starting contract \\u2014 the first thing you'll write every time you start a new project: pragma solidity ^0.4.25; contract HelloWorld \", \"Put it to the test To start creating our Zombie army, let's create a base contract called ZombieFactory. In the box to the right, make it so our contract uses solidity version 0.4.25. Create an empty contract called ZombieFactory. When you're finished, click \\\"check answer\\\" below. If you get stuck, you can click \\\"hint\\\". Chapter 2: Contracts Starting with the absolute basics: Solidity's code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications \\u2014 all variables and functions belong to a contract, and this will be the starting point of all your projects. An empty contract named HelloWorld would look like this: contract HelloWorld \", \"Version Pragma All solidity source code should start with a \\\"version pragma\\\" \\u2014 a declaration of the version of the Solidity compiler this code should use. This is to prevent issues with future compiler versions potentially introducing changes that would break your code. It looks like this: pragma solidity ^0.4.25; (for the latest solidity version at the time of this writing, 0.4.25). Putting it together, here is a bare-bones starting contract \\u2014 the first thing you'll write every time you start a new project: pragma solidity ^0.4.25; contract HelloWorld \", \"Put it to the test To start creating our Zombie army, let's create a base contract called ZombieFactory. In the box to the right, make it so our contract uses solidity version 0.4.25. Create an empty contract called ZombieFactory. When you're finished, click \\\"check answer\\\" below. If you get stuck, you can click \\\"hint\\\".\"));\n    }\n  }]);\n\n  return LessonBody;\n}(Component);\n\nexport default LessonBody;","map":{"version":3,"sources":["C:\\Users\\empty\\Documents\\IT\\CryptoViper\\cryptoviper\\src\\BodyComponent\\LessonComponent\\LessonBody.js"],"names":["React","Component","LessonBody"],"mappings":";;;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;;IAEMC,U;;;;;;;;;;;;;6BACK;AACP,aACE;AAAK,QAAA,KAAK,EAAC,YAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,29JADF,CADF;AAiID;;;;EAnIsBD,S;;AAqIzB,eAAeC,UAAf","sourcesContent":["import React, { Component } from 'react';\r\n\r\nclass LessonBody extends Component {\r\n  render() {\r\n    return (\r\n      <div class=\"lessonbody\">\r\n        <p>\r\n        Chapter 2: Contracts\r\nStarting with the absolute basics:\r\n\r\nSolidity's code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications — all variables and functions belong to a contract, and this will be the starting point of all your projects.\r\n\r\nAn empty contract named HelloWorld would look like this:\r\n\r\ncontract HelloWorld {\r\n\r\n}\r\nVersion Pragma\r\nAll solidity source code should start with a \"version pragma\" — a declaration of the version of the Solidity compiler this code should use. This is to prevent issues with future compiler versions potentially introducing changes that would break your code.\r\n\r\nIt looks like this: pragma solidity ^0.4.25; (for the latest solidity version at the time of this writing, 0.4.25).\r\n\r\nPutting it together, here is a bare-bones starting contract — the first thing you'll write every time you start a new project:\r\n\r\npragma solidity ^0.4.25;\r\n\r\ncontract HelloWorld {\r\n\r\n}\r\nPut it to the test\r\nTo start creating our Zombie army, let's create a base contract called ZombieFactory.\r\n\r\nIn the box to the right, make it so our contract uses solidity version 0.4.25.\r\n\r\nCreate an empty contract called ZombieFactory.\r\n\r\nWhen you're finished, click \"check answer\" below. If you get stuck, you can click \"hint\".\r\n\r\n        Chapter 2: Contracts\r\nStarting with the absolute basics:\r\n\r\nSolidity's code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications — all variables and functions belong to a contract, and this will be the starting point of all your projects.\r\n\r\nAn empty contract named HelloWorld would look like this:\r\n\r\ncontract HelloWorld {\r\n\r\n}\r\nVersion Pragma\r\nAll solidity source code should start with a \"version pragma\" — a declaration of the version of the Solidity compiler this code should use. This is to prevent issues with future compiler versions potentially introducing changes that would break your code.\r\n\r\nIt looks like this: pragma solidity ^0.4.25; (for the latest solidity version at the time of this writing, 0.4.25).\r\n\r\nPutting it together, here is a bare-bones starting contract — the first thing you'll write every time you start a new project:\r\n\r\npragma solidity ^0.4.25;\r\n\r\ncontract HelloWorld {\r\n\r\n}\r\nPut it to the test\r\nTo start creating our Zombie army, let's create a base contract called ZombieFactory.\r\n\r\nIn the box to the right, make it so our contract uses solidity version 0.4.25.\r\n\r\nCreate an empty contract called ZombieFactory.\r\n\r\nWhen you're finished, click \"check answer\" below. If you get stuck, you can click \"hint\".\r\n\r\n        Chapter 2: Contracts\r\nStarting with the absolute basics:\r\n\r\nSolidity's code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications — all variables and functions belong to a contract, and this will be the starting point of all your projects.\r\n\r\nAn empty contract named HelloWorld would look like this:\r\n\r\ncontract HelloWorld {\r\n\r\n}\r\nVersion Pragma\r\nAll solidity source code should start with a \"version pragma\" — a declaration of the version of the Solidity compiler this code should use. This is to prevent issues with future compiler versions potentially introducing changes that would break your code.\r\n\r\nIt looks like this: pragma solidity ^0.4.25; (for the latest solidity version at the time of this writing, 0.4.25).\r\n\r\nPutting it together, here is a bare-bones starting contract — the first thing you'll write every time you start a new project:\r\n\r\npragma solidity ^0.4.25;\r\n\r\ncontract HelloWorld {\r\n\r\n}\r\nPut it to the test\r\nTo start creating our Zombie army, let's create a base contract called ZombieFactory.\r\n\r\nIn the box to the right, make it so our contract uses solidity version 0.4.25.\r\n\r\nCreate an empty contract called ZombieFactory.\r\n\r\nWhen you're finished, click \"check answer\" below. If you get stuck, you can click \"hint\".\r\n\r\n        Chapter 2: Contracts\r\nStarting with the absolute basics:\r\n\r\nSolidity's code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications — all variables and functions belong to a contract, and this will be the starting point of all your projects.\r\n\r\nAn empty contract named HelloWorld would look like this:\r\n\r\ncontract HelloWorld {\r\n\r\n}\r\nVersion Pragma\r\nAll solidity source code should start with a \"version pragma\" — a declaration of the version of the Solidity compiler this code should use. This is to prevent issues with future compiler versions potentially introducing changes that would break your code.\r\n\r\nIt looks like this: pragma solidity ^0.4.25; (for the latest solidity version at the time of this writing, 0.4.25).\r\n\r\nPutting it together, here is a bare-bones starting contract — the first thing you'll write every time you start a new project:\r\n\r\npragma solidity ^0.4.25;\r\n\r\ncontract HelloWorld {\r\n\r\n}\r\nPut it to the test\r\nTo start creating our Zombie army, let's create a base contract called ZombieFactory.\r\n\r\nIn the box to the right, make it so our contract uses solidity version 0.4.25.\r\n\r\nCreate an empty contract called ZombieFactory.\r\n\r\nWhen you're finished, click \"check answer\" below. If you get stuck, you can click \"hint\".\r\n        </p>\r\n      </div>\r\n    )\r\n  }\r\n}\r\nexport default LessonBody;"]},"metadata":{},"sourceType":"module"}